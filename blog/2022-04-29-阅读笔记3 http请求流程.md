---
slug:  阅读笔记3 http请求流程
title: 阅读笔记3 http请求流程
authors:
  name: Nikki
  title: a coder
  # url: https://github.com/wgao19
  image_url: https://avatars.githubusercontent.com/u/59378631?s=400&u=5c50f7a8cf81217122611fb72484a0288d90a739&v=4
tags: [http]
---
回顾上文知识：

一个TCP连接过程包括了建立连接，传输数据，断开连接三个阶段。

HTTP协议正是建立在TCP连接基础之上的，它是一种允许浏览器向服务器获取资源的协议，是Web的基础。

带着问题阅读：

1.为什么通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快了？

2.当登录过一个网站之后，下次再访问该站点，就已经处于登录状态了，这是怎么做到的呢？

#### **浏览器发起HTTP请求流程**

**1.构建请求**

浏览器构建请求行信息（如下）

```
GET /index.html HTTP1.1
```

**2.查找缓存**

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。

当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。

如果缓存查找失败，就会进入网络请求过程了

**3.准备IP地址和端口**

HTTP的内容是通过TCP的传输数据阶段实现的

![img](https://static001.geekbang.org/resource/image/12/80/1277f342174b23f9442d3b27016d7980.png)

而建立TCP连接的第一步就是获取对应的IP地址和端口号

IP地址：通过**DNS域名解析系统**（拿到url中的域名解析出IP地址）获取，如果存在DNS缓存的话，可以直接从缓存中拿

端口号：如果url没有特别指明端口号，那http协议默认是80端口，https默认443端口

**4.等待TCP队列**

chrome有个机制，同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成

**5.建立TCP连接**

排队等待结束之后，开始建立TCP连接

**6.发送HTTP请求**

先发送请求行，再发送请求头和请求体（只发送一次）

- Host：当前请求的主机域名信息
- Connection：keep-alive 告诉服务器保持长连接，避免重复三次握手建立tcp连接
- Accept-Language：浏览器可以读取的语言
- Accept-Encodeing：浏览器可以支持的压缩方式
- Accept:浏览器支持的资源文件类型，如text/html
- Cookie:浏览器端的Cookie信息
- Cache-Control:浏览器端的缓存策略是强缓存
- User-Agent:浏览器内核和操作系统等信息

![img](https://static001.geekbang.org/resource/image/b8/d7/b8993c73f7b60feb9b8bd147545c47d7.png)

**7.服务器处理HTTP请求**

先返回响应行，再返回响应头，再返回响应体

![img](https://static001.geekbang.org/resource/image/3e/76/3e30476a4bbda49fd7cd4fd0ea09f076.png)

**8.断开TCP连接**

通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：

```
Connection:Keep-Alive
```

那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。**保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。**



考虑一种情况：

当我们在浏览器中打开geekbang.org时，打开的网址却是https://www.geekbang.org/，这两个url不一样的原因是，服务器做了一个**重定向**操作，当我们请求geekbang.org时，服务器会返回状态码301和重定向的地址，接下来，浏览器就会获取location字段中的地址，并使用该地址重新导航

![img](https://static001.geekbang.org/resource/image/28/43/28d5796c6ab7faa619ed8f1bd17b0843.jpg)

现在，思考刚刚提出的问题：

##### 1.为什么很多站点第二次打开速度会很快？

因为第一次加载过程中，进行了**DNS缓存**和**页面资源缓存**

页面资源缓存处理过程：

![img](https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png)

服务器通过控制响应头中的Cache-Control字段来设置是否缓存该资源，通常还会设置一个Max-Age参数来控制过期时长

```
//过期时长为2000秒
Cache-Control:Max-age=2000
```

在缓存资源还未过期时，再次请求该资源，会直接返回缓存中的资源给浏览器

如果过期了，浏览器会继续发起网络请求，并且在HTTP请求头中带上

```
If-None-Match:"4f80f-13c-3a1xb12a"
```

服务器根据If-None-Match的值来判断请求的资源是否有更新

- 没有更新，返回304状态码，使用浏览器缓存
- 有更新，返回200状态码和全新资源

##### 2.登录状态如何保持？

- 用户输入用户名密码，点击确定按钮，会调用POST方法提交用户登录信息给服务器

- 服务器收到信息后验证信息是否正确，正确的话，会生成一段表示用户身份的字符串，并且把这个字符串写到响应头的Set-Cookie字段里面，把响应头发送给浏览器

  ```
  Set-Cookie: UID=3431uad;
  ```

- 浏览器接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有Set-Cookie字段的情况，浏览器就会把这个字段信息保存到本地

- 当用户再次访问时，浏览器会发起HTTP请求，但在发起请求之前，浏览器会读取之前保存的cookie数据，并把数据写进请求头的Cookie字段里，然后浏览器再将请求头发送给浏览器

  ```
  Cookie: UID=3431uad;
  ```

- 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。

- 浏览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。

  ![img](https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png)

以上是cookie流程图

简单描述：

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。

![img](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png)

一些疑问：

1.浏览器刷新操作，ctrl+F5和F5有什么区别？

普通刷新页面，会走正常的缓存流程，比如强缓存和协商缓存。而强制刷新会跳过强缓存和协商缓存的过程，http 请求会缺少 if-none-match 字段，直接请求服务器重新拉取资源

2.一个域名下一次只能建立6个tcp连接是什么意思？

是同一个域名下面，同一时间只能有6个并发请求，超过六个以上的需要排队！

3.如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？

最好的方法是基于Network面板下的Timing来来进行分析。
Timing表示该请求的时间线轴线：

1. Quened at 36.01ms
   代表发送请求前的排队所消耗时间为36.01ms
   有可能是前面有正在发送的请求
   有可能是有的请求优先级比较高所以排队（network中有Priority选项代表请求的优先级）

   Started at 36.01ms
   正式开启请求时间

2. Connection Start 开始连接
   Stalled tcp链接复用 处理代理相关的逻辑所等待的时间
   DNS Lookup DNS域名解析消耗的时间
   Initial connection 创建TCP连接所消耗的时间
   SSL HTTPS请求进行SSL协商消耗的时间

3. Request/Response 请求响应阶段
   Request sent 发送请求的时间 很短 没法优化
   Waiting（TTFB）从发起请求到服务器返回首字节时间（可优化点：请求发出到响应总时长）
   Content Download 服务器返回的资源下载所需时间（可优化点：返回资源的大小会影响时间）