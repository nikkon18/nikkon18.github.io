---
slug: 执行上下文与变量提升
title: 执行上下文与变量提升
authors:
  name: Nikki
  title: a coder
  # url: https://github.com/wgao19
  image_url: https://avatars.githubusercontent.com/u/59378631?s=400&u=5c50f7a8cf81217122611fb72484a0288d90a739&v=4
tags: [js]
---

##### 变量提升：

1:所有的声明都会提升到作用域的最顶上去。

2:同一个变量只会声明一次，其他的会被忽略掉。

3:函数声明的优先级高于变量申明的优先级，并且函数声明和函数定义的部分一起被提升。

##### 为什么var会有变量提升，而let和const没有？

执行上下文：是一种对js代码执行环境的抽象概念，也就是说只要有js代码运行，那么它就一定是运行在执行上下文中

执行上下文的三种类型：

- 全局执行上下文（只有一个，浏览器中的全局对象就是window对象，this指向这个全局对象）
- 函数执行上下文（存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文）
- Eval函数执行上下文（指的是运行在eval函数中的代码，很少用且不建议使用）

执行上下文的生命周期：

创建阶段---->执行阶段---->回收阶段

##### 创建阶段：

- 确认this的值
- 创建词法环境（全局环境，函数环境）
- 创建变量环境（也叫词法环境，具有词法环境的所有属性）

ES6中，词法环境和变量环境的区别在于，词法环境用于存储函数声明和变量（let和const）绑定，而变量环境仅用于存储变量（var）绑定

##### 执行阶段：

变量赋值，代码执行

如果 `Javascript` 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 `undefined` 值

##### 回收阶段：

执行上下文出栈等待虚拟机回收执行上下文

##### 变量提升的实际原因：

在执行上下文的创建阶段，会在代码中扫描变量和函数声明，然后将函数声明存储在环境中，但var声明的变量会被初始化为undefined，而let和const声明的变量还是保持uninitialized

##### 执行栈：

具有后进先出结构，用于存储在代码执行期间创建的所有执行上下文

当`Javascript`引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中

每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中

引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文

###### 扩展知识点

let、const、var的区别：
（1）块级作用域： 块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：
内层变量可能覆盖外层变量
用来计数的循环变量泄露为全局变量

（2）变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。

（3）给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。

（4）重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。

（5）暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。

（6）初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。

（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

