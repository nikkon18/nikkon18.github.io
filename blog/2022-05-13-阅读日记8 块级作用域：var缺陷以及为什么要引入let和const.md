---
slug:  阅读日记8 块级作用域：var缺陷以及为什么要引入let和const
title: 阅读日记8 块级作用域：var缺陷以及为什么要引入let和const
authors:
  name: Nikki
  title: a coder
  # url: https://github.com/wgao19
  image_url: https://avatars.githubusercontent.com/u/59378631?s=400&u=5c50f7a8cf81217122611fb72484a0288d90a739&v=4
tags: [js变量提升]
---
**作用域**是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗来说，作用域就是**变量与函数的可访问范围**，即作用域控制着变量的函数的可见性和生命周期。

ES6之前的作用域：

- 全局作用域
- 函数作用域

ES6新增：

- 块级作用域

简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

##### 没有块级作用域的坏处：

导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是**变量提升**

##### 变量提升带来的问题：

1.变量容易在不被察觉的情况下被覆盖掉

2.本应销毁的变量没有被销毁（例子：for循环+var声明变量）

##### ES6如何解决变量提升的问题：

引入let和const关键字

两者区别：使用let关键字声明的变量是可以被改变的，而使用const声明的变量值是不可以被改变的

这两个关键字支持块级作用域，在编译阶段，js引擎并不会把块中通过let和const声明的变量存放到变量环境中，这也就意味着**在块中通过let和const声明的变量，并不会提升到全函数可见**

##### js是如何支持块级作用域的？

js引擎是通过变量环境实现函数级作用域的

```js
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

以上代码的执行流程：

##### 第一步，编译并创建执行上下文

以下是执行时foo函数的执行上下文

![img](https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png)

通过上图，我们可以得出以下结论：

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到**变量环境**里面了。
- 通过 let 声明的变量，在编译阶段会被存放到**词法环境**（Lexical Environment）中。
- 在函数的**作用域块内部**，通过 let 声明的变量并**没有**被存放到词法环境中。

##### 第二步，继续执行代码

当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：

![img](https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png)

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。

查找变量a的过程：先找词法环境，再找变量环境

![img](https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png)

当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：

![img](https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png)

块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两种的结合，js引擎就同时支持了变量提升和块级作用域了。

##### 思考

以下代码的打印结果：

```js
let myname= '极客时间'
{
  console.log(myname) 
  let myname= '极客邦'
}
```

结果：

VM6277:3 Uncaught ReferenceError: Cannot access 'myname' before initialization

原因：

在块级作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成暂时性死区

拓展：

var的创建和初始化被提升，赋值不会被提升。

let的创建被提升，初始化和赋值不会被提升。

function的创建、初始化和赋值均会被提升。

#### 变量提升和暂时性死区的区别：

变量提升：编译时把var声明的变量放到变量环境，进入块级作用域是不编译的，所以不存在变量提升

暂时性死区：在初始化前使用变量，会形成暂时性死区，用var声明的变量会在创建是就进行初始化undefined，而let和cont声明的变量初始化时会被置为uninitialized标志位，在没有执行到赋值行时便对其进行访问，就会报暂时性死区错误