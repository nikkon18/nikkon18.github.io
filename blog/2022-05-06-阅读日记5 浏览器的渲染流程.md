---
slug:  阅读日记5 浏览器的渲染流程
title: 阅读日记5 浏览器的渲染流程
authors:
  name: Nikki
  title: a coder
  # url: https://github.com/wgao19
  image_url: https://avatars.githubusercontent.com/u/59378631?s=400&u=5c50f7a8cf81217122611fb72484a0288d90a739&v=4
tags: [浏览器]
---
渲染模块的处理流程叫**渲染流水线**，大致流程如下：

构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成

##### 构建DOM树

将HTML文件经过HTML解析器解析，最终输出树状结构的DOM，通过js可以操作dom

##### 样式计算

目的是为了计算出DOM节点中每个元素的具体样式

1. 把css转换为浏览器能够理解的结构----styleSheets
2. 转换样式表中的属性值，使其标准化
3. 计算出DOM树中每个节点的具体样式（考虑继承规则和层叠规则）

##### 布局阶段

布局指的是计算出DOM树中可见元素的几何位置的过程

1. 创建只包含可见元素的布局树
2. 布局计算

**以上阶段总结：**

在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。



##### 分层

为了方便实现3D变换、页面滚动等效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树（LayerTree）。

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面

![img](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png)

为新节点创建新图层的条件：

- 拥有层叠上下文属性的元素会被提升为单独一层

  层叠上下文指的是HTML元素按照自身属性的优先级分布在垂直于这个二维平面的z轴上

  ![img](https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png)

  拥有明确定位属性的元素，定义透明属性的元素，使用css滤镜的元素等，都拥有层叠上下文属性

- 需要裁剪的地方也会被创建为图层

##### 图层绘制

渲染引擎会把一个图层的绘制拆分成很多很小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

![img](https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png)

##### 栅格化操作

实际上的绘制操作是由渲染引擎中的合成线程完成的，当图层的绘制列表准备好之后，主线程会把该绘制列表**提交**给合成线程

合成线程会将图层划分为图块，大小通常是256x256或者512x512

![img](https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png)

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。**所谓栅格化，是将图块转换为位图**。

渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

![img](https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png)

##### 合成与显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。



整个渲染的流水线：

![img](https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png)

以上的总结，一个完整的渲染流程如下：

1. 渲染进程将 HTML 内容转换为能够读懂的 **DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 **styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令 **DrawQuad** 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。



##### 再思考三个常见的概念：

**重排、重绘、合成**

##### 1.重排：更新了元素的几何属性（宽度高度等）

浏览器会触发重新布局，解析之后的一系列子阶段

![img](https://static001.geekbang.org/resource/image/b3/e5/b3ed565230fe4f5c1886304a8ff754e5.png)

##### 2.重绘：更新元素的绘制属性（背景颜色等）

布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段

![img](https://static001.geekbang.org/resource/image/3c/03/3c1b7310648cccbf6aa4a42ad0202b03.png)

##### 3.合成：更改一个既不要布局也不要绘制的属性（使用transform实现动画效果）

渲染引擎将跳过布局和绘制，只执行后续的合成操作



一些Q&A：

减少重绘重排的方法：

1. 使用 class 操作样式，而不是频繁操作 style 
2. 避免使用 table 布局 
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React 
4. Debounce window resize 事件 
5. 对 dom 属性的读写要分离  
6. will-change: transform 做优化


