---
slug: 事件模型
title: 事件模型
authors:
  name: Nikki
  title: a coder
  # url: https://github.com/wgao19
  image_url: https://avatars.githubusercontent.com/u/59378631?s=400&u=5c50f7a8cf81217122611fb72484a0288d90a739&v=4
tags: [js]
---

事件模型有三种：

- 原始事件模型(DOM0级)

- 标准事件模型(DOM2级)
- IE事件模型(基本不用)

##### 原始事件模型：

- HTML代码里绑定 onclick="func()"
- js代码绑定  document.getElementById('.btn').onclick = fun

特性：

绑定速度快

只支持冒泡，不支持捕获

同一个类型的事件只能绑定一次

##### 标准事件模型：

事件的三个过程：

- 事件捕获阶段：事件从`document`一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行

绑定监听函数的方式：

addEventListener(eventType,handler,useCapture)

-eventType 指定事件类型 不加on

-useCapture 是否在捕获阶段进行处理，一般为false，然后在冒泡过程中执行

特性：

可以在一个dom元素上绑定多个事件处理器，各自不会冲突

##### IE事件模型

IE事件模型共有两个过程:

- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行

事件绑定监听函数的方式如下:

```text
attachEvent(eventType, handler)
```

事件移除监听函数的方式如下:

```text
detachEvent(eventType, handler)
```

#### 事件代理（事件委托）

事件代理和事件委托实际上说的是同一件事，只是站在不同的角度来说的。比如说元素A把事件处理委托给自己的父元素B去处理，那么A就是事件委托方，而B就是事件代理方，两者参与的实际上是同一件事。

事件委托就是把一个或者一组元素的事件委托给它的父层或者更外层元素上

当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数

应用场景：

1.有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件

传统做法：给每一个列表项都绑定一个点击函数，但是它的内存消耗非常大

事件委托：把点击事件绑定在父级元素ul上面，执行事件时去匹配目标元素（所点击的元素为e.target）

适合事件委托的事件：click、mousedown、keydown、keyup、keypress

优点：

- 减少整个页面所需的内存，提升整体性能
- 动态绑定，减少重复工作

局限性：

- `focus`、`blur`这些事件没有事件冒泡机制，所以无法进行委托绑定事件
- `mousemove`、`mouseout`这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的